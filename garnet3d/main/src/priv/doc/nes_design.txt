OVERVIEW
========
The basic idea comes from the famous thread "material/shader system" on gamedev 
forum:
  - Each effect is a c++ class (bunch of code) that user don't know its 
    implementation detail, which is similar to general stream processing unit. 
  - Effect class accepts 2 kinds of inputs: 1) buffer, 2) const
    - Buffer is a data storage that stores vertex and/or pixel data in GPU 
      friendly format. User can access buffer data by various lock/unlock 
      operations.

OPEN ISSUES
===========
- Is it beneficial to group different types of constants into single buffer?
  - Check D3D10 constant buffer for more ideas.

RESOLVED USER SCENARIOS
=======================
- one shader output a 2D texture that is used as input of another shader that 
  requires 3D texture.
- one shader output a 2D texture that is used by many-many of other shaders.
- 2 draws use same shader. the 1st draw render to texture; the second draw 
  to back buffer.

OPENED USER SCENARIOS
=====================
- generate cube texture then use it as environment map
  - 
- render to one face of a cube texture, one slice of a 3D texture, or one 
  mipmap of a 2D texture.
- separate depth and stencil buffer. (Does user really need such a scenario?)
- Adjust global quality parameter (like texture filtering), to increase overall
  rendering quality.
- user creates too many render targets that can't fit into hardware's local
  memory (like EDRAM)
  - may be resolved by lazy creation
  - check CPU "register renaming" and "buffer renaming" in graphics driver for
    more ideas.
- shader get data from general CPU data buffer.
  - read vertices from fat vertex buffer
  - read DXT texture from uncompressed texture
  - read cubemap from 6 2D textures
