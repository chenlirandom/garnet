<?xml version="1.0" encoding="utf-8"?>
<effect>
    <parameters>
        <uniform name="pvw" type="MATRIX44" count="1"/>
        <uniform name="invworld" type="MATRIX44" count="1" desc="inverse world matrix"/>
        <uniform name="light0_pos" type="VECTOR4" count="1" desc="light position in world space"/>
        <uniform name="diffuse" type="VECTOR4" count="1"/>
        <texture name="texdiff" desc="diffuse map"/>
        <texture name="texnormal" desc="normal map"/>
    </parameters>
    <shaders>

        <!-- D3D shaders -->

        <shader name="d3dvs" type="VS">
            <prerequisites>
                <token type="opcode" value="CHECK_SHADER_PROFILE">
                    <token type="values" value="vs_1_1"/>
                </token>
            </prerequisites>
            <uniref binding="pvw" ref="pvw"/>
            <uniref binding="invworld" ref="invworld"/>
            <uniref binding="light0_pos" ref="light0_pos"/>
            <code lang="D3D_HLSL" hints="...">
<![CDATA[
struct vsinput
{
	float4 pos : POSITION;
	float3 nrm : NORMAL;
	float2 tex : TEXCOORD0;
};
struct vsoutput
{
	float4 pos  : POSITION;
	float4 nrm  : TEXCOORD0; // xyz: normal in object space;          w : texcoord.u
	float4 lpos : TEXCOORD1; // xyz: light direction in object space; w : texcoord.v
};
uniform float4x4 pvw;
uniform float4x4 invworld;
uniform float4   light0_pos; // light position in world space
vsoutput main( vsinput vi )
{
	vsoutput vo;

	// get light direction in object space
	float3 lightpos_os = mul( invworld, light0_pos );
	float3 lightdir_os = lightpos_os - vi.pos.xyz;

	vo.pos      = mul( pvw, vi.pos );
	vo.nrm.xyz  = vi.nrm;
	vo.nrm.w    = vi.tex.x;
	vo.lpos.xyz = lightdir_os;
	vo.lpos.w   = vi.tex.y;

	return vo;
}
]]>
            </code>
        </shader>

        <shader name="d3dps" type="PS">
            <prerequisites>
                <token type="opcode" value="CHECK_SHADER_PROFILE">
                    <token type="values" value="ps_1_4"/>
                </token>
            </prerequisites>
            <texref stage="0" ref="texdiff"/>
            <texref stage="1" ref="texnormal"/>
            <code lang="D3D_HLSL">
<![CDATA[
struct vsoutput
{
	float4 nrm  : TEXCOORD0; // xyz: normal in object space;          w: texcoord.u
	float4 lpos : TEXCOORD1; // xyz: light position in object space; w : texcoord.v
};
sampler texdiff : register(s0);
sampler texnormal : register(s1);
float4 main( vsoutput vi ) : COLOR0
{
	float diffuse = clamp( dot( normalize(vi.nrm.xyz), normalize(vi.lpos.xyz) ), 0, 1 );
	float lighting = diffuse + 0.2;

	float4 tex = tex2D( texdiff, float2( vi.nrm.w, vi.lpos.w ) );

	return tex * lighting;
}
]]>
            </code>
        </shader>

        <!-- Fixed functional pipeline -->
        <shader name="fixvs" type="VS"/>
        <shader name="fixps" type="PS"/>
        <shader name="fixgs" type="GS"/>

    </shaders>

    <techniques>
        <technique name="d3d">
            <pass vs="d3dvs" ps="d3dps" gs="fixgs"/>
        </technique>
        <technique name="ffp">
            <pass vs="fixvs" ps="fixps" gs="fixgs"/>
        </technique>
    </techniques>
</effect>
