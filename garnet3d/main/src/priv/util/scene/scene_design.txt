. NOT BE TOO GENERAILIZED!


main loop
=========

    thread 0:
    handle object management and update
    while(1)
    {
        for( all_objects )
        {
            obj->update(); // in fixed time step, 1/60s for example.
        }
    }

    rendering thread (:
    handle tasks that need to access rendering device.
    while(1)
    {
        for( all_visible_objects )
        {
            obj->draw();
        }
    }

FEATURE LIST
============

. All object are subclass of SceneNode, which has unique ID and name
. The class of the object has unique type ID.
	. Can we use C++ inherited RTTI?
. Whold world can be load from and save to a XML file.
	. requires object ID and type ID.
. multiple cameras
	. to support mirrors, maybe
. multiple threads
	. one thread for object management
		. check visible objects
			...
	. one thread for rendering
		. do blinding rendering of all visible objects
			...
. dynamic scene object management (multi-threads safe)
	. allow runtime insertion.
	. allowing runtime object dispose.
		. based on LRU table.
		. need carefully design to avoid too much locks.
	. object IDs will never be deleted and reused.
	. several object list:
		. ready-to-use list
		. prepare-to-dispose list
		. prepare-to-load list

main components
===============

. world
  . sky
  . terrain
  . river
  . building
  . plants
. actors
  . characters
  . particles
  . projectiles
. weather
  . wind
  . rain
  . snow

ISSUES
======

. who's responsible of node creation?
	. by scene loader
		. load node from file:
			. create node instance based on its type name
			. call LoadFrom...() of the node
		. or load node
		. quick prototyping will be hard.
	. user can't create node instance directly.
. who's responsible of node deletion?
	. TBD
