top level loop
==============

    thread 0:
    handle object management and update
    while(1)
    {
        for( all_objects )
        {
            obj->update(); // in fixed time step, 1/60s for example.
        }
    }

    rendering thread (:
    handle tasks that need to access rendering device.
    while(1)
    {
        for( all_visible_objects )
        {
            obj->draw();
        }
    }


FEATURE LIST
============

. ID <-> object
    . 1-1 mapping
    . why we need this?
      . for save and load
. object -> name
    . uniqname or not?
. object -> typeid (rtti)
    . how?
. scene save and load
    . requires ID and typeid
. multiple cameras
. multiple threads
    . one thread for object management
        . check visible objects
        ...
    . one thread for rendering
        . do blinding rendering of all visible objects
        ...
. dynamic scene object management (multi-threads safe)
  . allow runtime insertion.
  . allowing runtime object dispose.
    . based on LRU table.
    . need carefully design to avoid too much locks.
  . object IDs will never be deleted and reused.
  . several object list:
    . ready-to-use list
    . prepare-to-dispose list
    . prepare-to-load list

ISSUES
======

. do we need unique object name?
  . pros: can ref other objects by name, in definition file.
  . cons: too retrict. I like arbitry name.