<?xml version="1.0" encoding="utf-8"?>
<effect>
    <parameters>
        <uniform name="pvw" type="MATRIX44" count="1"/>
        <uniform name="invworld" type="MATRIX44" count="1" desc="inverse world matrix"/>
        <uniform name="light0_pos" type="VECTOR4" count="1" desc="light position in world space"/>
        <uniform name="diffuse" type="VECTOR4" count="1"/>
        <texture name="texdiff"/>
        <texture name="texbump"/>
    </parameters>
    <gpuprograms>

        <!-- D3D gpuprograms -->

        <gpuprogram lang="HLSL9">
            <prerequisites/>
            <uniref shaderParameter="pvw" uniform="pvw"/>
            <uniref shaderParameter="invworld" uniform="invworld"/>
            <uniref shaderParameter="light0_pos" uniform="light0_pos"/>
            <texref shaderParameter="texdiff" texture="texdiff"/>
            <vs entry="main">
<![CDATA[
struct vsinput
{
	float4 pos : POSITION;
	float3 nrm : NORMAL;
	float2 tex : TEXCOORD0;
};
struct vsoutput
{
	float4 pos  : POSITION;
	float4 nrm  : TEXCOORD0; // xyz: normal in object space;          w : texcoord.u
	float4 lpos : TEXCOORD1; // xyz: light direction in object space; w : texcoord.v
};
uniform float4x4 pvw;
uniform float4x4 invworld;
uniform float4   light0_pos; // light position in world space
vsoutput main( vsinput vi )
{
	vsoutput vo;

	// get light direction in object space
	float3 lightpos_os = mul( invworld, light0_pos );
	float3 lightdir_os = lightpos_os - vi.pos.xyz;

	vo.pos      = mul( pvw, vi.pos );
	vo.nrm.xyz  = vi.nrm;
	vo.nrm.w    = vi.tex.x;
	vo.lpos.xyz = lightdir_os;
	vo.lpos.w   = vi.tex.y;

	return vo;
}
]]>
            </vs>
            <ps entry="main">
<![CDATA[
struct vsoutput
{
	float4 nrm  : TEXCOORD0; // xyz: normal in object space;         w : texcoord.u
	float4 lpos : TEXCOORD1; // xyz: light position in object space; w : texcoord.v
};
sampler texdiff : register(s0);
float4 main( vsoutput vi ) : COLOR0
{
	float lighting = 0.1 + clamp( dot( normalize(vi.nrm.xyz), normalize(vi.lpos.xyz) ), 0, 1 );

	float4 tex = tex2D( texdiff, float2( vi.nrm.w, vi.lpos.w ) );

	return tex * lighting;
}
]]>
            </ps>
        </gpuprogram>

        <!-- Cg gpuprograms -->

        <gpuprogram name="cg">
            <prerequisites/>
            <uniref shaderParameter="pvw" uniform="pvw"/>
            <uniref shaderParameter="invworld" uniform="invworld"/>
            <uniref shaderParameter="light0_pos" uniform="light0_pos"/>
            <texref shaderParameter="texdiff" texture="texdiff"/>
            <vs entry="main">
<![CDATA[
struct vsinput
{
	float4 pos : POSITION;
	float3 nrm : NORMAL;
	float2 tex : TEXCOORD0;
};
struct vsoutput
{
	float4 pos  : POSITION;
	float4 nrm  : TEXCOORD0; // xyz: normal in object space;          w : texcoord.u
	float4 lpos : TEXCOORD1; // xyz: light direction in object space; w : texcoord.v
};
uniform float4x4 pvw;
uniform float4x4 invworld;
uniform float4   light0_pos; // light position in world space
vsoutput main( vsinput vi )
{
	vsoutput vo;

	// get light direction in object space
	float3 lightpos_os = mul( invworld, light0_pos );
	float3 lightdir_os = lightpos_os - vi.pos.xyz;

	vo.pos      = mul( pvw, vi.pos );
	vo.nrm.xyz  = vi.nrm;
	vo.nrm.w    = vi.tex.x;
	vo.lpos.xyz = lightdir_os;
	vo.lpos.w   = vi.tex.y;

	return vo;
}
]]>
            </vs>
            <ps entry="main">
<![CDATA[
struct vsoutput
{
	float4 nrm  : TEXCOORD0; // xyz: normal in object space;         w : texcoord.u
	float4 lpos : TEXCOORD1; // xyz: light position in object space; w : texcoord.v
};
sampler texdiff : register(s0);
float4 main( vsoutput vi ) : COLOR0
{
	float lighting = 0.1 + clamp( dot( normalize(vi.nrm.xyz), normalize(vi.lpos.xyz) ), 0, 1 );

	float4 tex = tex2D( texdiff, float2( vi.nrm.w, vi.lpos.w ) );

	return tex * lighting;
}
]]>
            </ps>
        </gpuprogram>
    </gpuprograms>

    <techniques>
        <technique name="d3d">
            <pass gpuprogram="d3d"/>
        </technique>
        <technique name="cg">
            <pass gpuprogram="cg"/>
        </technique>
    </techniques>
</effect>
