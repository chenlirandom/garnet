# -*- coding: GB18030 -*-

import sys, os, os.path, re, fnmatch

# try import xenon extension for SCons
try:
	sys.path.append( "env/scons/xenon" )
	import xenon
	CONF_has_xenon_extension = True
except ImportError:
	CONF_has_xenon_extension = False
	print "no xenon extension for scons found."

################################################################################
#
# Local Utilities
#
################################################################################

# 读取环境变量
def UTIL_getenv( name, defval = '' ):
	if name in os.environ: return os.environ[name]
	else: return defval

# 输出调试信息
def UTIL_trace( level, msg ):
	level = float(level)
	assert( 0 != level )
	if ( CONF_trace > 0 and level <= CONF_trace ) or ( CONF_trace < 0 and level == -CONF_trace ):
		print 'TRACE(%d) : %s'%(level,msg)

# 输出提示信息
def UTIL_info( msg ): print 'INFO : %s'%msg

# 输出警告信息
def UTIL_warn( msg ):
	#print '===================================================================='
	print 'WARNING : %s'%msg
	#print '===================================================================='

# 输出错误信息
def UTIL_error( msg ):
	print '===================================================================='
	print 'ERROR : %s'%msg
	print '===================================================================='

################################################################################
#
# Configurations (part 1/2)
#
################################################################################

LOCAL_ENV = Environment( tools=[] )

HOST_OS  = None
HOST_CPU = None
if 'win32' == LOCAL_ENV['PLATFORM']:
	HOST_OS = 'mswin'
	if 'AMD64' == UTIL_getenv('PROCESSOR_ARCHITECTURE') or 'AMD64' == UTIL_getenv('PROCESSOR_ARCHITEW6432'):
		HOST_CPU = 'x64'
	else:
		HOST_CPU = 'x86'
elif 'cygwin' == LOCAL_ENV['PLATFORM']:
	HOST_OS = 'cygwin'
	HOST_CPU = 'x86'
elif 'posix' == LOCAL_ENV['PLATFORM']:
	HOST_OS = 'posix'
	HOST_CPU = 'x86'
else:
	print 'FATAL: Unknown platform:', LOCAL_ENV['PLATFORM']
	Exit(-1)

HOST_COMPILER = UTIL_getenv('GN_BUILD_COMPILER', None )
if None == HOST_COMPILER:
	if CONF_has_xenon_extension and xenon.exists( LOCAL_ENV ):
		HOST_COMPILER = 'xenon'
	elif 'mswin' == HOST_OS:
		HOST_COMPILER = 'vc100'
	else:
		HOST_COMPILER = 'gcc'

BUILD_VARIANT = UTIL_getenv('GN_BUILD_VARIANT', 'debug')

BUILD_TARGET_OS = UTIL_getenv('GN_BUILD_TARGET_OS', HOST_OS )

BUILD_TARGET_CPU = UTIL_getenv('GN_BUILD_TARGET_CPU', HOST_CPU )

BUILD_ROOT_PATH = 'b2.tmp/' + BUILD_TARGET_OS + '.' + BUILD_TARGET_CPU + '.' + HOST_COMPILER + '.' + BUILD_VARIANT + "/"

################################################################################
#
# Create default build envrionment
#
################################################################################

# Create new environment
def BUILD_newEnv( msvcBatchMode ):

	env = Environment(
		MSVC_BATCH = msvcBatchMode
		)

	# Import environment variables that are used by C/C++ compiler.
 	env.PrependENVPath( 'PATH'     , UTIL_getenv('PATH') );
 	env.PrependENVPath( 'INCLUDE'  , UTIL_getenv('INCLUDE') );
 	env.PrependENVPath( 'LIB'      , UTIL_getenv('LIB') );
 	env['ENV']['LANG']     = UTIL_getenv('LANG');
 	env['ENV']['LANGUAGE'] = UTIL_getenv('LANGUAGE');

	# cache implicit dependencies
	env.SetOption( 'implicit_cache', 1 );

	# setup default decider
	env.Decider( 'MD5-timestamp' );

	# setup signature file
	env.SConsignFile( BUILD_ROOT_PATH + '.sconsign' )

	# Set standard include path
	env.Append(
		CPPPATH = [
			'#src/extern/inc',
			'#' + BUILD_ROOT_PATH + 'priv/inc',
			'#src/priv/inc',
			],
		)

	# Platform specific options
	if 'xenon' == HOST_OS:
		pass
	elif 'mswin' == HOST_OS:
		pass;

	# Compiler specific options
	if 'cl' == env['CC']:
		env.Append(
			CXXFLAGS = ['/EHsc']
			)

	return env

################################################################################
#
# Configurations (part 2/2)
#
################################################################################

#CONFIG_env = BUILD_newEnv( msvcBatchMode = False )
#CONFIG_conf = CONFIG_env.Configure(...)

################################################################################
#
# 定义 GarnetEnv class
#
################################################################################

class GarnetEnv2 :

	def __init__( self ) :

		#
		# Build configurations
		#
		self.target_os    = BUILD_TARGET_OS
		self.target_cpu   = BUILD_TARGET_CPU
		self.host_os      = HOST_OS
		self.cc           = HOST_COMPILER
		self.static_build = True # TODO: run platform detector
		# TODO: run header/lib detector
		self.has_ogl      = True
		self.ogl_libs     = ['opengl32','glu32'] # or ['GLU','GL','X11'] on Linux
		self.has_dxerr    = True
		self.has_xnamath  = True
		self.has_d3d9     = True
		self.has_d3d10    = True
		self.has_d3d11    = True
		self.has_xtl      = True
		self.has_iconv    = False
		self.has_xinput   = True
		self.has_xinput2  = True
		self.has_dinput   = True

		#
		# List of known targets that are created by NewTarget method
		#
		self.targets = {}

	#
	# Logging
	#
	def Trace( self, level, msg ): UTIL_trace( level, msg )
	def Info( self, msg ): UTIL_info( msg )
	def Warn( self, msg ): UTIL_warn( msg )
	def Error( self, msg ): UTIL_error( msg )

	#
	# 生成从target到base的相对路径
	#
	def RelativePath( self, target, base ):
		"""
		Return a relative path to the target from either the current dir or an optional base dir.
		Base can be a directory specified either as absolute or relative to current dir.
		"""

		base_list = (os.path.abspath(base)).split(os.sep)
		target_list = (os.path.abspath(target)).split(os.sep)

		# On the windows platform the target may be on a completely different drive from the base.
		if os.name in ['nt','dos','os2'] and base_list[0] <> target_list[0]:
			raise OSError, 'Target is on a different drive to base. Target: '+target_list[0].upper()+', base: '+base_list[0].upper()

		# Starting from the filepath root, work out how much of the filepath is
		# shared by base and target.
		for i in range(min(len(base_list), len(target_list))):
			if base_list[i] <> target_list[i]: break
		else:
			# If we broke out of the loop, i is pointing to the first differing path elements.
			# If we didn't break out of the loop, i is pointing to identical path elements.
			# Increment i so that in all cases it points to the first differing path elements.
			i+=1

		rel_list = [os.pardir] * (len(base_list)-i) + target_list[i:]
		return os.path.join(*rel_list)

	#
	# 查找指定目录下的文件
	#
	def Glob( self, patterns, recursive = False ):
		def do_glob( pattern, dir, recursive ):
			files = []
			root = Dir(dir).srcnode().abspath;
			try:
				for file in os.listdir( root ):
					if os.path.isdir( os.path.join(root,file) ):
						if recursive and ( not '.svn' == file ) : # ignore subversion directory
							files = files + do_glob( pattern, os.path.join(dir,file), recursive )
					else:
						# Note: ignore precompiled headers and makefiles
						if not ('pch.cpp' == file or 'stdafx.cpp' == file or 'makefile.scons' == file):
							#print 'fnmatch(%s,%s) = %s'%(file,pattern,fnmatch.fnmatch(file, pattern))
							if fnmatch.fnmatch(file, pattern):
								files.append( os.path.join( dir, file ) )
			except WindowsError:
				pass
			return files
		#print 'glob %s'%patterns )
		files = []
		if not patterns is list: patterns = [patterns]
		for p in Flatten(patterns):
			if os.path.isdir( GetBuildPath(p) ):
				#print '    do_glob(*.*,%s)'%p
				files += do_glob( '*.*', p, recursive )
			else:
				(dir,pattern) = os.path.split(p);
				if '' == pattern: pattern = '*.*';
				if '' == dir: dir = '.';
				#print '    do_glob(%s,%s)'%(pattern,dir)
				files += do_glob( pattern, dir, recursive )
		return files

	#
	# Create new build environment
	#
	def NewEnv( self, msvcBatchMode = True ) : return BUILD_newEnv( msvcBatchMode )

	#
	# Remove items from environment list
	#
	def RemoveEnvListItems( self, env, name, toBeRemoved ):
		if toBeRemoved:
			for x in toBeRemoved:
				if x in env[name]:
					env[name].remove(x)

	#
	# setup environment for producing PCH, return PCH object file
	#
	def SetupPCH( self, env, pchHeader, pchSource ):
		if 'PCH' in env['BUILDERS'] and pchSource:
			pch = env.PCH(pchSource)
			env['PCH'] = pch[0]
			env['PCHSTOP'] = pchHeader
			if( len(pch) > 1 ):
				return [pch[1]]
			else:
				return []
		else:
			return []

	#
	# Setup build environment to produce PDB file
	#
	def SetupPDB( self, env, target, pdb ):
		if pdb : pdbfile = File(pdb)
		else   : pdbfile = File("%s.pdb"%(target))
		env['PDB'] = pdbfile

	#
	# Build list of static object files from list of sources
	#
	def BuildObjects( self, sources, pchHeader=None, pchSource=None, env = None ):
		if not env: env = self.NewEnv()
		pchobj = self.SetupPCH( env, pchHeader, pchSource )
		return Flatten( [env.Object(x) for x in sources] ) + pchobj

	#
	# Build static library from list of objects
	#
	def BuildLib( self, target, objects, pdb=None, env=None ):
		if not env: env = self.NewEnv()
		self.SetupPDB( env, target, pdb )
		return env.Library( target, objects )

	#
	# Copy a set of files to build output folder.
	#
	# To preserve tree structure in sources, all pathes in sources must be relative path.
	#
	def CopyToBinFolder( self, subfolder, sources, preserveDirectoryTree ):
		if '' == subfolder : subfolder = '.'
		targets = []
		for x in sources:
			dst = '#' + BUILD_ROOT_PATH + '/' + subfolder + '/'
			if preserveDirectoryTree:
				dst += x
			else:
				dst += os.path.basename( x )
			Command( dst, x, Copy( "$TARGET", "$SOURCE" ) )
			targets.append( dst )
		return targets

	#
	# Copy one file to Xenon devkit
	#
	def CopyToDevkit( target, source ):
		xedk=UTIL_getenv("XEDK")
		xbcp='%s\\bin\\win32\\xbcp.exe'%(xedk)
		# Note: xbcp.exe requires environment variable "SystemRoot".
		cmdline = 'set SystemRoot=%s&"%s" /Q /D /Y /T "%s" %s'%(UTIL_getenv("SystemRoot"),xbcp,x.abspath,self.targetDir)
		env.Execute( cmdline )

	#
	# Create alias for a build target. So that it can be
	# referenced easily in makefiles.
	#
	def NewTarget( self, name, target, addToDefault = False ):

		# See if the alias has existed already.
		if self.FindTarget(name, warnForNonExistTarget = False):
			self.Error( 'Alias %s has existed.'%(name) )
			return

		# Create scons alias.
		Alias( name, target )
		if addToDefault :
			Default( name )

		# Add to alias list
		self.targets[name] = target

	#
	# Create alias for a build target. Also add it into default target list.
	#
	def NewDefaultTarget( self, name, target ): return self.NewTarget( name, target, addToDefault = True )

	#
	# Find target by name.
	#
	def FindTarget( self, name, warnForNonExistTarget = True ):
		if name in self.targets:
			return self.targets[name]
		else:
			if warnForNonExistTarget: self.Warn( 'Target %s does not exist.'%(name) )
			return None

# Create garnet build environment (singleton)
GN = GarnetEnv2()

################################################################################
#
# Build subfolders
#
################################################################################
Export( 'GN' )
SConscript( 'src/makefile.scons', variant_dir=BUILD_ROOT_PATH, duplicate=1)
